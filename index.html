<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title></title>
	<link rel="stylesheet" href="./index.css">
	<script type="text/javascript" src="./jq.js"></script>
	<script type="text/javascript" src="./AudioContext.js"></script>
	<script type="text/javascript" src="./LaunchpadController.js"></script>
	<script type="text/javascript">
		$(function(){

			const BASE = 'http://192.168.0.';
			const API = '/cm?cmnd=';

			const LOW = 10;
			const HIGH = 25;

			const COUNT = 40;

			let audio = new AudioContext();
			audio.add('blip','./audio/sfx-blip.mp3');
			audio.add('blip-low','./audio/sfx-blip-low.mp3');
			audio.add('woosh','./audio/sfx-woosh.mp3');
			audio.add('boom','./audio/sfx-boom.mp3');
			audio.add('on','./audio/sfx-on.mp3');
			audio.add('off','./audio/sfx-off.mp3');

			let bpm = 115;

			const COLORS = {
				'off':[0,0,0],
				'white':[255,255,255,255],
				'red':[255,0,0,0],
				'green':[0,255,0,0],
				'blue':[0,0,255,0],
				'purple':[255,0,255,0],
				'yellow':[255,255,0,0],
			}

			const PALETTE = ['red','green','blue','purple','yellow'];

			let littles = [];
			let bigs = [];

			let $anchor = $('<anchor>').appendTo('body');
			for(var i=0; i<COUNT; i++){

				let r = (i+0.5)/COUNT*Math.PI*2;

				littles[i] = new Light(LOW+i);
				littles[i].$el.appendTo($anchor).css({
					left: Math.sin(-r) * 30 + 'vh',
					top: Math.cos(-r) * 30 + 'vh',
					transform: 'translate(-50%, -50%) rotate('+(r)+'rad)',
				});
			}

			let $logo = $('<logo>').appendTo($anchor);

			let launchpad = new LaunchpadController(onPianoMessage);
			launchpad.$el.appendTo('body');
			launchpad.listen(function(n,x,y,b){
				
				if(b) $(`button[x=${x}][y=${y}]`).click();
			})

			
			let nKey = -1;
			function onPianoMessage(e){
				//console.log(e.target.name);
				if(e.data[0]==144 && e.data[2]>0) doMidiKey(e.target.name.includes('minilogue'));
			}


			let pianoPulse = [];
			let nKorg = Math.round( littles.length * 0.25 );
			let nPiano = Math.round( littles.length * 0.75 );
			function doMidiKey(isMinilogue){
				nKey++;
				if(isMinilogue) doKorgKey();
				else doPianoKey();
				//for(var n in bigs) bigs[n].setColor(cycle[nKey%cycle.length]).commit();
				//for(var n in littles) littles[n].setColor(cycle[nKey%cycle.length]).commit();
			}

			function doKorgKey(){
				nKorg = Math.round( (0.1 + Math.random() * 0.3)*littles.length );
				/*if(pianoPulse.length && (pianoPulse[0].n + (pianoPulse[0].size+2)) > littles.length) return; // prevent overlap
				pianoPulse.unshift({ n:littles.length, size:2, dir:-1, color:'blue', min:COUNT/2, max:COUNT });*/
			}

			function doPianoKey(){
				
				nPiano = Math.round( (0.6 + Math.random() * 0.3)*littles.length );
				/*if(pianoPulse.length && (pianoPulse[0].n - (pianoPulse[0].size+1)) < 0) return; //prevent overlap
				console.log('doKorgKey');
				pianoPulse.unshift({ n:-1, size:2, dir:1, color:'red', min:0, max:COUNT/2 });*/
			}

			function Light(ip){

				let self = this;
				self.$el = $('<light>');
				let backlog = [];

				self.setOn = function(b) {
					backlog.push( 'Power '+(b?'On':'Off'))
					return self;
				}
				
				self.setFade = function(b) {
					backlog.push('Fade '+(b?'1':'0'));
					return self;
				}

				self.setWhite = function(opacity=1){
					backlog.push('Color 255,255,255,'+Math.floor(opacity*255));
					return self;
				}

				self.setColor = function(colorName,opacity=1){

					let color = COLORS[colorName];

					self.setRGBWO(color[0],color[1],color[2],color[3],colorName=='off'?0:opacity);
					return self;
				}

				self.setRGBWO = function(r,g,b,w,opacity=1) {
					self.$el.css({
						'background':'linear-gradient( to bottom, transparent, rgb('+r+','+g+','+b+'))',
						'opacity':opacity,
					})

					backlog.push('Color '+
					Math.floor(r*opacity)+
					','+
					Math.floor(g*opacity)+
					','+
					Math.floor(b*opacity)+
					','+
					Math.floor(w*opacity)
					);
					return self;
				}

				self.setSpeed = function( ms ){
					//ms must be converted into a multiplier for 0.5s 
					let nHalfSeconds = Math.round(ms/500);
					backlog.push('Speed '+nHalfSeconds);
					return self;
				}

				self.setSpeed2 = function( ms ){
					//ms must be converted into a multiplier for 0.5s 
					let nHalfSeconds = Math.round(ms/500);
					backlog.push('Speed2 '+nHalfSeconds);
					return self;
				}

				self.setDelay = function( ms ){
					//ms must be converted into a multiplier for 0.1s 
					let nTenthSeconds = Math.round(ms/100);
					backlog.push('Delay '+nTenthSeconds);
					return self;
				}

				self.init = function() {
					self.setOn(true).setFade(false).setSpeed(0).setColor('green').commit(false);
					return self;
				}

				self.commit = function(skipToEnd=true){
					if(backlog.length){
						backlog = [ backlog[backlog.length-1] ];
						self.send();
					}
					return self;
				}

				let cntFetch = 0;
				let noCors = {mode:'no-cors'};
				self.send = function(){
					let cmnd;
					cmnd = 'Backlog '+backlog.join('%3B').replaceAll(' ','%20');
					backlog.length = 0;
					cntFetch++;
					//fetch(BASE+ip+API+cmnd, { signal: AbortSignal.timeout(2000) }).then(onFetch).catch(onCatch);
				}

				function onFetch(e){
					self.$el.attr('state','connected');
				}

				function onCatch(e){
					//console.log(ip,'ERROR',e);
					self.$el.attr('state','error');
				}

				self.init();
			}

			function shuffle(array) {
			  let currentIndex = array.length;

			  // While there remain elements to shuffle...
			  while (currentIndex != 0) {

			    // Pick a remaining element...
			    let randomIndex = Math.floor(Math.random() * currentIndex);
			    currentIndex--;

			    // And swap it with the current element.
			    [array[currentIndex], array[randomIndex]] = [
			      array[randomIndex], array[currentIndex]];
			  }
			}


			let nRed = -1;
			function doNextRed(){
				nRed++;
				littles[nRed].setColor('red').commit();
			}

			let nSpin = 0;
			let colorStep = 'red';
			function doStepSpin(){
				let nPrev = (nSpin-10+littles.length)%littles.length;
				littles[nPrev].setColor('off').commit();
				nSpin = (nSpin+1)%littles.length;
				littles[nSpin].setColor(colorStep).commit();
			}

			let arrSpin = [0,Math.floor(COUNT/3),Math.floor(COUNT/3*2)];
			let arrColor = ['red','blue','green'];
			function doStepRainbow(){
				
				for(i in arrSpin){
					let nPrev = (arrSpin[i]-3+littles.length)%littles.length;
					littles[nPrev].setColor('off').commit();

					let nFade = (arrSpin[i]-1+littles.length)%littles.length;
					littles[nFade].setColor(arrColor[i],0.5).commit();
				}

				for(i in arrSpin) arrSpin[i]++;

				for(i in arrSpin){
					let nNow = arrSpin[i]%littles.length;
					littles[nNow].setColor(arrColor[i]).commit();
				}
			}

			function doStepCandle(){
				let n = Math.floor(Math.random()*littles.length);
				littles[n].setRGBWO(120+Math.random()*20,50+Math.random()*20,0,0,Math.random()).commit();
			}

			function doStepOff(){
				let next = pendingOff.pop();
				if(next) next.setColor('off').commit();
				else{
					doColor('off');
					fnStep = undefined;
				}
			}

			function doColor(color, opacity=1){
				
				for(var n in littles){
					let c = (color=='random')?PALETTE[Math.floor(Math.random()*PALETTE.length)]:color;
					littles[n].setColor(c, opacity).commit();
				}
			}

			let nx = -1;
			let ny = 0;
			let $btns = [];
			function addButton(color,str,fn){
				nx++;
				launchpad.setXY(0,nx,ny,color);
				$btns.push( $(`<button x=${nx} y=${ny}>${str}</button>`).appendTo('debug').click(fn) );
			}

			function addBreak(){
				nx = -1;
				ny++;
				$('<br>').appendTo('debug');
			}

			let pendingOff = [];
			function doTwinkleOff(){
				pendingOff = littles.concat();
				shuffle(pendingOff);
				fnStep = doStepOff;
			}

			let colorDecay = 'white';
			function doDecay(color){
				colorDecay = color;
				nFade = FPDECAY + FPS/2;
				fnStep = doDecayStep;
			}

			function doDecayStep(){
				
				if(FPDECAY<= FPDECAY && nFade >= 0 && nFade%FPFADESTEP==0) doColor(colorDecay,nFade/FPDECAY);
				nFade--;
			}

			let nTwinkle = 0;
			function doStepTwinkle(){
				littles[nTwinkle].setColor('off').commit();
				nTwinkle = Math.floor(Math.random()*littles.length);
				littles[nTwinkle].setColor('white',0.1).commit();
			}

			function doPianoMode(){
				doColor('off');
				//fnStep = doStepPianoPulse;
				fnStep = doStepPiano;
			}

			const FPDECAY = 30;
			const FPFADESTEP = 2;

			let nKorgWas = nKorg;
			let nPianoWas = nPiano;

			let colorKorg = [0,0,0,0];
			let colorPiano = [0,0,0,0];

			let decayMap = [];
			for(var i in littles) decayMap[i] = -1;

			function doStepPiano(){

				if(nKorg != nKorgWas){
					decayMap[nKorgWas-2] = 0;
					decayMap[nKorgWas-1] = 0;
					decayMap[nKorgWas] = 0;
					decayMap[nKorgWas+1] = 0;
					decayMap[nKorgWas+2] = 0;

					nKorgWas = nKorg;

					decayMap[nKorgWas-2] = 10;
					decayMap[nKorgWas-1] = 15;
					decayMap[nKorgWas] = 20;
					decayMap[nKorgWas+1] = 15;
					decayMap[nKorgWas+2] = 10;

					colorKorg = [255,Math.floor(Math.random()*255),0,0];
				}

				if(nPiano != nPianoWas){

					decayMap[nPianoWas-2] = 0;
					decayMap[nPianoWas-1] = 0;
					decayMap[nPianoWas] = 0;
					decayMap[nPianoWas+1]= 0;
					decayMap[nPianoWas+2]= 0;

					nPianoWas = nPiano;

					decayMap[nPianoWas-2] = 10;
					decayMap[nPianoWas-1] = 15;
					decayMap[nPianoWas] = 20;
					decayMap[nPianoWas+1] = 15;
					decayMap[nPianoWas+2] = 10;

					colorPiano = [0,Math.floor(Math.random()*255),100+Math.floor(Math.random()*155),0];
				}

				

				for(var i in decayMap){
					if(decayMap[i] >= 0 && decayMap[i]%FPFADESTEP==0){
						let c =  i>littles.length/2?colorPiano:colorKorg;
						littles[i].setRGBWO( c[0], c[1], c[2], c[3], decayMap[i]/FPDECAY).commit();
						//littles[i].setColor(, decayMap[i]/FPDECAY ).commit();
					}
				}
				for(var i in decayMap) decayMap[i]--;
			}	


			

			function doStepPianoPulse(){

				for(var n in pianoPulse) pianoPulse[n].n += pianoPulse[n].dir;


				for(var n in pianoPulse) if( littles[ pianoPulse[n].n-pianoPulse[n].size*pianoPulse[n].dir ])littles[ pianoPulse[n].n-pianoPulse[n].size*pianoPulse[n].dir ].setColor('off');
				for(var n in pianoPulse){
					if( pianoPulse[n].n < pianoPulse[n].max &&
						pianoPulse[n].n >= pianoPulse[n].min &&
						littles[ pianoPulse[n].n ]) littles[ pianoPulse[n].n ].setColor( pianoPulse[n].color );
				}

				for(var n in littles ) littles[n].commit();

				//CLEAR OLD PULSES (NOT WORKING)
				for(var i=0; i<pianoPulse.length; i++){
					let a = pianoPulse[i].n;
					let b = pianoPulse[i].n - pianoPulse[i].size * pianoPulse[i].dir;
					if(a < pianoPulse[i].min && b < pianoPulse[i].min && a > pianoPulse[i].max && b > pianoPulse[i].max){
						pianoPulse.splice(i,1);
						i--;
					}
				}

				console.log(pianoPulse.length);

			}


			const FPS = 20;
			let fnStep = undefined;
			function step() {

				if(fnStep) fnStep();
			}

			let timeStart = new Date().getTime();
			setInterval(step,1000/FPS);

			addButton('white','text-next',doNextRed);
			
			addBreak();
			addButton('red','spin-r',function(){ colorStep='red'; fnStep = doStepSpin; });
			addButton('green','spin-g',function(){ colorStep='green'; fnStep = doStepSpin; });
			addButton('blue','spin-b',function(){ colorStep='blue'; fnStep = doStepSpin; });
			addButton('white','spin-w',function(){ colorStep='white'; fnStep = doStepSpin; });
			addBreak();
			addButton('white','spin-rainbow',function(){ fnStep = doStepRainbow; });
			addBreak();
			addBreak();
			addButton('red','left',function(){ 
				audio.play('blip',true);
				fnStep = undefined; 
				for(var n=0; n<littles.length; n++) littles[n].setColor(n<littles.length/2?'red':'off').commit(); 
			})
			addButton('blue','right',function(){ 
				audio.play('blip-low',true);
				fnStep = undefined; 
				for(var n=0; n<littles.length; n++) littles[n].setColor(n>=littles.length/2?'blue':'off').commit(); 
			})
			
			addButton('white','left-right',doLeftRight);
			
			function doLeftRight(){
				audio.play('blip',true);
				audio.play('blip-low',true);
				for(var n=0; n<littles.length; n++) littles[n].setColor(n<littles.length/2?'red':'blue').commit(); 
				nFocus = -5;
				fnStep = doStepLeftRight;
			}

			let nFocus = 0;
			function doStepLeftRight(){
				nFocus++;
				if(nFocus>=0 && nFocus<=7){
					littles[nFocus].setColor('off').commit();
					littles[COUNT-nFocus-1].setColor('off').commit();
					littles[COUNT/2-nFocus-1].setColor('off').commit();
					littles[COUNT/2+nFocus].setColor('off').commit();
				}
				
			}
			
			

			addBreak();
			addButton('white','flash',function(){ audio.play('boom',true); doColor('white', 1); doDecay('white'); });
			addButton('white','woosh',function(){ audio.play('woosh',true); doColor('white'); fnStep = doStepRainbow; });
			addButton('orange','candles',function(){ doColor('off'); fnStep = doStepCandle; });
			addButton('yellow','twinkle',function(){ doColor('off'); fnStep = doStepTwinkle; });
			addBreak();
			addBreak();
			addButton('white','midi-start',function(){ doPianoMode(); });
			addButton('blue','midi-piano',function(){ doPianoKey(); });
			addButton('red','midi-korg',function(){ doKorgKey(); });
			addBreak();
			
			addButton('white','off',function(){ fnStep=undefined; doColor('off'); });
		})

		
	</script>
	<style type="text/css">
		body{
			background: black;
			color: black;
			font-family: monospace;
			background: url(./bg.gif);
			background-size: 110%;
			background-position: center;

			overflow: hidden;
			width: 100vw;
			height: 100vh;
			margin: 0px;
			padding: 0px;
		}

		bpm{
			display: block;
			color: white;
			padding: 10px 0px;
		}

		bpm:before{
			content: "";
			width: 15px;
			height: 15px;
			border-radius: 100%;
			background: white;
			display: inline-block;
			vertical-align: middle;
			margin-right: 10px;
		}

		bpm:after{
			content: "BPM";
			display: inline-block;
			vertical-align: middle;
		}

		bpm[on=true]:before{
			opacity: 1;
		}

		bpm[on=false]:before{
			opacity: 0;
		}

		anchor{
			display: block;
			position: absolute;
			top: 50%;
			left: 50%;
			width: 0px;
			height: 0px;
		}

		logo{
			content: "";
			width: 80vh;
			height: 80vh;
			background: url(./logo.png);
			background-size: 100%;
			background-position: center;
			background-repeat: no-repeat;

			display: block;
			transform: translate(-50%, -50%);
			position: absolute;
			top: 0px;
			left: 0px;

			mix-blend-mode: overlay;
			
		}

		light{
			position: absolute;
			width: 72px;
			height: 400px;
			background: black;
			
			
			display: block;
			transform: translate(-50%, -50%);

			clip-path: polygon(0% 100%, 100% 100%, 55% 0%, 45% 0%);
		}

		light[state='connected']{
			opacity: 1;
		}

		light[state='error']{
			/*border: 1px solid red;*/
		}

		h1{
			margin: 0px;
			padding: 0px;
			text-align: center;
			font-size: 50px;
			line-height: 100vh;
			font-weight: bold;
			text-shadow: -20px 20px 50px red, 20px -20px 50px blue; 
		}

		debug{
			display: block;
			position: fixed;
			bottom: 0px;
			left: 0px;
			margin: 20px;
		}

		button{
			display: inline-block;
			
			font: inherit;
			color: white;
			text-align: left;
			background: none;
			border: none;
			padding: 5px;
			position: relative;
			
		}

	</style>
</head>
<body>
	<debug></debug>
</body>
</html>